# 错误处理设计文档

## 1. 需求分析

**主需求**：

​		根据给定的文法设计并实现错误处理程序，能诊察出常见的语法和语义错误，进行错误局部化处理，并输出错误信息。

**输入输出**：

1. 输入的被编译源文件统一命名为`testfile.txt`，错误信息输出到命名为`error.txt`的结果文件中。

2. 结果文件中包含如下两种信息：

   错误所在的行号 错误的类别码

   行号与类别码之间只有一个空格，类别码严格按照表格中的小写英文字母。

**错误类别码定义**：

|                       错误类型                       | 错误类别码 |                          解释及举例                          |         ErrorType         |
| :--------------------------------------------------: | :--------: | :----------------------------------------------------------: | :-----------------------: |
|                 非法符号或不符合词法                 |     a      | 例如**字符与字符串中出现非法的符号**，**符号串中无任何符号** |       InvalidSymbol       |
|                      名字重定义                      |     b      |        **同一作用域内出现相同的名字**（不区分大小写）        |       NameRedefine        |
|                     未定义的名字                     |     c      |                     **引用未定义的名字**                     |       NameNotDefine       |
|                  函数参数个数不匹配                  |     d      |             函数调用时实参个数大于或小于形参个数             |      ArgsNumNotMatch      |
|                  函数参数类型不匹配                  |     e      | 函数调用时形参为整型，实参为字符型；或形参为字符型，实参为整型 |     ArgsTypeNotMatch      |
|              条件判断中出现不合法的类型              |     f      | 条件判断的左右表达式只能为整型，其中任一表达式为字符型即报错，例如'a' == 1 | ConditionJudgeInvalidType |
|         无返回值的函数存在不匹配的return语句         |     g      | 无返回值的函数中可以没有return语句，也可以有形如return;的语句，若出现了形如return(表达式);或return();的语句均报此错误 |      NoRetFuncReturn      |
| 有返回值的函数缺少return语句或存在不匹配的return语句 |     h      | 例如有返回值的函数无任何返回语句；或有形如return;的语句；或有形如return();的语句；或return语句中表达式类型与返回值类型不一致 |     RetFuncMissReturn     |
|            数组元素的下标只能是整型表达式            |     i      |                  数组元素的下标不能是字符型                  |      ArrIndexNotInt       |
|                   不能改变常量的值                   |     j      | 这里的常量指的是声明为const的标识符。例如 const int a=1;在后续代码中如果出现了修改a值的代码，如给a赋值或用scanf获取a的值，则报错。 |        ModifyConst        |
|                       应为分号                       |     k      | 应该出现分号的地方没有分号，例如int x=1缺少分号（7种语句末尾，for语句中，常量定义末尾，变量定义末尾） |        SemicnMiss         |
|                   应为右小括号')'                    |     I      | 应该出现右小括号的地方没有右小括号，例如fun(a,b;，缺少右小括号（有/无参数函数定义，主函数，带括号的表达式，if，while，for，switch，有/无参数函数调用，读、写、return） |        RparentMiss        |
|                   应为右中括号']'                    |     m      | 应该出现右中括号的地方没有右中括号，例如int arr[2;缺少右中括号（一维/二维数组变量定义有/无初始化，因子中的一维/二维数组元素，赋值语句中的数组元素） |        RbrackMiss         |
|                 数组初始化个数不匹配                 |     n      | 任一维度的元素个数不匹配，或缺少某一维的元素即报错。例如int a[2] [2]={{1,2,3},{1,2}} |      ArrInitNotMatch      |
|                   <常量>类型不一致                   |     o      | 变量定义及初始化和switch语句中的<常量>必须与声明的类型一致。int x=’c’;int y;switch(y){case(‘1’) ….} |      VarTypeNotMatch      |
|                     缺少缺省语句                     |     p      |                switch语句中，缺少<缺省>语句。                |        MissDefault        |

**附加要求**：

1. 本次考核之外，发现错误时最好直接输出描述信息，而不是仅给出错误类型或错误情况 。

   **解决方案：设置两个布尔型常量`ERROR_TYPE_OUTPUT`和`ERROR_DESCRIPTION_ERROR`来控制两种不同的输出。**

2. 每一行中最多只有一个错误。

3. 所有错误都不会出现恶意换行的情况，包括字符、字符串中的换行符、函数调用等等。

4. 其他类型的错误，错误的行号以能够断定发现出错的一个符号的行号为准。例如有返回值的函数缺少返回语句的错误，只有当识别到函数末尾的}时仍未出现返回语句，才可以断定出错，报错行号即为}的行号。

## 2. Pascal-S编译器错误处理

> 根据PASCAL-S文法的定义，阅读编译器源代码，了解符号表的设计实现方案和错误处理实现方案；在此基础上，为自己的编译器添加符号表管理、错误处理功能（包括语法错误和语义错误），编译器源代码见pascals-compiler.docx。

​		Pascal-S的出错处理基本上沿用了PL/0的处理方法，采取了以下一些措施：

​		（1）对于在程序中遗漏了像“;”号或明显的保留字之类的符号时，或者当程序员误用了像“:=”号或“=”号之类的符号时，则除报告出错信息外，只要简单地**填上或改正这些符号**便可予以**校正**，使编译继续进行下去；

​		（2）在每个语法分析子程序出口处，检测**下一个取来的符号**是否为该语法成分的**合法后继符号**或**停止符号集合**，若不是，则应报告出错信息，并且跳读一段源程序，直至取来的符号属于该语法成分的合法后继符号集合或停止符号集合为止。停止符号集合里可以放置若干明显的能使程序重新开始分析的保留字或者其他终结符号。

​		……

## 3. 编码前设计

#### 3.1 符号表

​		我们符号表采用组织形式的是**栈式符号表**，在这种组织形式下，当遇到**识别符声明**时，就将包含有标识符属性的记录**推入堆栈**。当到达**分程序结尾**时，就将这个分程序中声明的所有标识符的记录**移出堆栈**。

> 其中，有一点疑问：书上强调一个分程序的符号表信息可能在编译的各个阶段都需要被访问，例如语法分析、语义分析、代码优化和代码生成等。因此通常情况下，编译器会为每个被编译的分程序设计一个独立的数据结构或者内存空间来存放它的符号表，直到该分程序的所有编译阶段都完成后再删除或释放相应符号表占用的空间。由于我们实现的是一遍扫描的生成程序，所以理论上在语法分析程序中一个分程序执行完毕，编译阶段的工作已经完成了，所以似乎不再需要设计一个内存空间来存放符号表，直接从栈中弹出即可（？）。正确性有待商榷，因此将需要将弹栈设计成一个函数，便于之后修改。

​		在栈式符号表中**插入**操作，只需要将新纪录推入栈顶单元即可。在分程序结构的语言中允许在不同分程序中存在重复的名字声明，因此在插入前要检查名字是否有重复声明的错误。使用线性查找法时，**只需要检查正在编译的最后一个分程序中所声明的名字记录**就可以了。

​		**查表**操作需要对表进行从顶到底的线性搜索。

​		在栈式符号表的**定位**操作中，在分程序索引表的顶端将产生一个新的分程序索引项，并赋予当前符号表栈栈顶的地址。

​		**重定位**操作将有效地清楚刚刚被编译完的分程序在栈式符号表中的所有记录；也可以是物理上把被删除的记录移到一个失效区中。

**具体实现**：

​		`symbol.h`中定义一个符号的基类`Symbol`，具体类成员变量和类成员函数的属性及含义如下所示。

| 类成员变量名 | 访问修饰符 |    类型    |            含义            |
| :----------: | :--------: | :--------: | :------------------------: |
| symbol_name  | protected  |   string   |         符号的名字         |
| symbol_type  | protected  | SymbolType |         符号的类型         |
| symbol_level | protected  |    int     | 符号声明所在的分程序的层次 |

|   类成员函数名   | 访问修饰符 |                输入参数                 |  返回类型  |              含义              |
| :--------------: | :--------: | :-------------------------------------: | :--------: | :----------------------------: |
|      Symbol      |   public   | string name, SymbolType type, int level |   Symbol   |            构造函数            |
|     ~Symbol      |   public   |                  void                   |    void    |            析构函数            |
| get_symbol_name  |   public   |                  void                   |   string   |         返回符号的名字         |
| get_symbol_type  |   public   |                  void                   | SymbolType |         返回符号的类型         |
| get_symbol_level |   public   |                  void                   |    int     | 返回符号声明所在的分程序的层次 |

​		其中，`SymbolType`为自己定义的枚举类，具体枚举变量如下。

```c++
enum SymbolType {
	IntConSym,		// 整型常量符号
	CharConSym,		// 字符常量符号
	IntVarSym,		// 整型变量符号
	CharVarSym,		// 字符变量符号
	IntArrSym,		// 整型数组符号
	CharArrSym,		// 字符数组符号
	VoidFuncSym,	// 无返回值函数符号
	IntFuncSym,		// 返回整型函数符号
	CharFuncSym,	// 返回字符函数符号
};
```

​		基于`Symbol`基类，有派生出了三个派生类`VarSymbol`、`ArrSymbol`和`FuncSymbol`，分别表示变量和常量符号、数组符号和函数符号。

​		`VarSymbol`的具体类成员变量和类成员函数的属性及含义如下所示。

|   类成员变量名   | 访问修饰符 | 类型 |          含义          |
| :--------------: | :--------: | :--: | :--------------------: |
| var_symbol_value |  private   | int  | 变量符号或常量符号的值 |

|     类成员函数名     | 访问修饰符 |                输入参数                 | 返回类型 |            含义            |
| :------------------: | :--------: | :-------------------------------------: | :------: | :------------------------: |
|      VarSymbol       |   public   | string name, SymbolType type, int level |   void   |          构造函数          |
|      ~VarSymbol      |   public   |                  void                   |   void   |          析构函数          |
| set_var_symbol_value |   public   |                int value                |   void   | 设置变量符号或常量符号的值 |
| get_var_symbol_value |   public   |                  void                   |   int    | 返回变量符号或常量符号的值 |

​		`ArrSymbol`的具体类成员变量和类成员函数的属性及含义如下所示。

|     类成员变量名     | 访问修饰符 |     类型      |      含义      |
| :------------------: | :--------: | :-----------: | :------------: |
| arr_symbol_dimension |  private   | vector< int > | 数组符号的维数 |

|       类成员函数名       | 访问修饰符 |                输入参数                 |   返回类型    |        含义        |
| :----------------------: | :--------: | :-------------------------------------: | :-----------: | :----------------: |
|        ArrSymbol         |   public   | string name, SymbolType type, int level |     void      |      构造函数      |
|        ~ArrSymbol        |   public   |                  void                   |     void      |      析构函数      |
| add_arr_symbol_dimension |   public   |              int dimension              |     void      | 增加数组符号的维数 |
| get_arr_symbol_dimension |   public   |                  void                   | vector< int > | 返回数组符号的维数 |

​		`FuncSymbol`的具体类成员和类成员函数的属性及含义如下所示。

|   类成员变量名   | 访问修饰符 |        类型         |      含义      |
| :--------------: | :--------: | :-----------------: | :------------: |
| func_symbol_args |  private   | vector< VarSymbol > | 函数符号的参数 |

|     类成员函数名     | 访问修饰符 |                输入参数                 |       返回类型       |        含义        |
| :------------------: | :--------: | :-------------------------------------: | :------------------: | :----------------: |
|      FuncSymbol      |   public   | string name, SymbolType type, int level |         void         |      构造函数      |
|     ~FuncSymbol      |   public   |                  void                   |         void         |      析构函数      |
| add_func_symbol_args |   public   |              VarSymbol arg              |         void         | 增加函数符号的参数 |
| get_func_symbol_args |   public   |                  void                   | vector < VarSymbol > | 返回函数符号的参数 |

​		`symbol.h`中定义一个名为`symbol_table`的命名空间，其中包含一个类型为`std::vector<Symbol>`的符号向量容器`symbol_vector`和一个类型为`std::unordered_map<std::string, std::vector<int>>`的无序哈希表`name2index_map`。

​		`symbol_vector`按顺序记录符号，`name2index_map`记录某符号名在`symbol_vector`中对应的索引vector，因为在不同分程序中允许存在重复的名字声明。每次插入符号时，如果`name2index_map`中存在相同`name`的键，只需要判断该name对应的索引vector的最后一项索引对应的符号的level和插入的符号的level是否相同即可。

#### 3.2 错误处理

​		对于有错误的源程序，不能一发现有错误就停止编译，而是要对错误做适当的处理，从而使编译工作能继续往下进行。

​		源程序中的错误，分为**语法错误**和**语义错误**。语法错误是值程序结构**不符合语法（包括词法）规则**的情况。语义错误则包括两个方面，即**程序不符合语义规则**或**超越具体计算机系统的限制**。本次错误处理主要针对语法错误和语义错误中程序不符合语义规则的部分。

##### **错误局部化处理**

​		错误局部化处理是指**当编译程序发现错误以后，尽可能设法把错误限制在一个局部的范围内，避免错误扩散和影响程序其他部分的分析和检查**。

​		**具体做法**是当检查出错误以后，编译程序就暂停对后面的符号进行分析，跳过错误所在的语法单位。例如，在词法分析时，跳过出错的单词，找到下一个新的单词并继续往下分析。在语法分析时，则跳过错误所在的短语或语句，找到下一个新的短语或新的语句，然后继续往下分析。

​		在用递归下降分析法进行语法分析过程中，一旦检查出错误，就将错误性质传至变量`cx`，然后转出错处理程序。出错处理程序先报告（打印或显示）错误信息（位置、性质），然后跳过一段源程序，一般跳到语句的右界符，并从新语句开始接着往下分析。但是，在跳读时，要跳过尽量少的一段源程序，使后面的副作用尽可能小。常用的方法是**根据所分析的语法成分预先指定右界符，出错时，根据指定的右界符来跳过一段源程序，而不是一出错就跳至新语句**。以ALGOL语言的for循环语句为例：

```
for V := e1 step e2 until e3 do
	statement;
```

对上述for循环语句，若e1中出错可跳到step，e2中出错可跳到until，e3中出错可跳到do，等等。

​		实现上述提高错误处理局部化程度的方法是**在编译程序中设置一个专用变量，用以存放指定的右界符。出错处理时，按该变量的内容和语句右界符的并集跳过一段源程序**。为了实现上述错误局部化的处理方法，为出错处理局部化提供保证，编译程序应预先进行括号配对检查，实现方法很简单，只需设一个括号栈，遇左括号时，左括号进栈。遇右括号时，检查栈顶括号是否与其相匹配，若匹配则将左括号从栈顶弹出；若不匹配或分析结束时括号栈不空，则说明括号不配对。

​		错误处理时还需要**遏止重复的错误信息**，只要建立一张出错名字表，每当发现一个出错名字后，首先查出错名字表，查找有无同名并同性质的出错名字，若有，则不再打印错误信息；否则就把它登入该表中，并记录该出错名字的各种不正确用法，再把错误信息打印出来。

##### 具体实现：

**1. 非法符号或不符合词法：**

​		只考虑**非法符号出现在字符与字符串中和符号串中无任何符号的错误**，不考虑非法符号出现在其他地方的情况（例如像某个标识符是`c?t`等情况不考虑）。

​		当词法分析程序`lexer.cpp`读符号时，读到双引号，如果后一位也是双引号，则报错；如果不是，继续往下读，直到读到下一个双引号（如果没有后双引号就死循环啦），并且在读的过程中遇到非法字符，就报错，并且不加入字符串中。

​		当词法分析程序`lexer.cpp`读符号时，读到单引号，如果后一位不是合法字符，则报错，且继续读直到读到下一个单引号（没有后单引号就死循环了）；如果是，则再读一位，判断是否是单引号，如果不是，则报错，且继续读直到读到下一个单引号。

**2. 名字重定义：**

​		在函数定义、变量定义或常量定义时，每次都需要调用`AddVarSymbol`、`AddArrSymbol`或`AddFuncSymbol`将标识符插入符号栈`symbol_ptr_vector`和`name2index_map`，首先都会调用`IsNameRedefined`函数检查<名字重定义>错误，即如果`name2index_map`中存在相同`name`的键，只需要判断该键值对中**最新插入的同名标识符的`level`和即将要加入的标识符的`level`是否相同**，如果相同，则报<名词重定义>错误。

**3. 未定义的名字：**

​		在使用标识符前，先使用`IsNameDefined`函数检查之前是否插入过该标识符，若没有，则报<未定义的名字>错误。

**4. 函数参数个数不匹配：**

​		在使用函数调用语句时，在获得`vector<ExprType>`类型的值参数表后，调用`CheckPara`函数，检查**值参数表中的参数个数**与符号栈中**该函数的参数`func_symbol_args`个数**是否符合，若不符合，则报<函数参数个数不匹配>错误。

**5. 函数参数类型不匹配：**

​		在使用函数调用语句时，在获得`vector<ExprType>`类型的值参数表后，调用`CheckPara`函数，检查**值参数表中的参数类型**与符号栈中**该函数的参数`func_symbol_args`类型**是否符合，若不符合，则报<函数参数类型不匹配>错误。

**6. 条件判断中出现不合法的类型：**

​		在<条件>的递归分析子程序中，如果<关系运算符>左右两边的<表达式>有一个不是整型表达式，则报<条件判断中出现不合法的类型>错误。

**7. 无返回值的函数存在不匹配的return语句：**

​		设置一个`ReturnState`枚举类全局变量`return_state`，`ReturnState`枚举类如下所示。

```c++
enum ReturnState {
	InNoRetFunc,				// 在无返回值函数定义
	InIntRetFuncNoReturn,		// 在返回整型的函数定义中且无return
	InCharRetFuncNoReturn,		// 在返回字符型的函数定义且无return
	InIntRetFuncWithReturn,		// 在返回整型的函数定义中且已有return
	InCharRetFuncWithReturn,	// 在返回字符型的函数定义中且已有return
	NotInFunc					// 不在函数定义
};
```

​		`return_state`初值为`NotInFunc`。当进入一个<无返回值函数定义>或<主函数>的递归分析子程序时，`return_state`变为`InNoRetFunc`。

​		如果之后进入了<返回语句>的递归分析子程序并出现了`return(`的格式，则报<无返回值的函数存在不匹配的return语句>错误。

​		在退出<无返回值函数定义>或<主函数>的递归分析子程序时，将`return_state`变为`NotInFunc`。

**8. 有返回值的函数缺少return语句或存在不匹配的return语句：**

​		同理，依旧是`ReturnState`枚举类全局变量`return_state`，初值为`NotInFunc`。

​		当进入一个<有返回值函数定义>的递归分析主程序时，`return_state`根据函数类型变为`InIntRetFuncNoReturn`或`InCharRetFuncNoReturn`。

​		如果之后进入了<返回语句>的递归分析子程序，则`return_state`变为`InIntRetFuncWithReturn`或`InCharRetFuncWithReturn`；并且如果出现了`return;`或`return()`的格式或者`return`后表达式类型和函数类型不匹配时，报<有返回值的函数缺少return语句或存在不匹配的return语句>错误。

​		在退出<有返回值的函数缺少return语句或存在不匹配的return语句>的递归分析子程序时，将`return_state`变为`NotIntFunc`。

**9. 数组元素的下标只能是整型表达式：**

​		当使用数组标识符时，判断其下标是否是整型表达式，如果不是，则报<数组元素的下标只能是整型表达式>错误。

**10. 不能改变常量的值**：

​		当修改标识符的值时，需首先使用`GetSymbolLatestType`函数得到该标识符最新的类型，如果是常量符号，则报<不能改变常量的值>错误。

**11. 应为分号：**

​		在应该出现分号的时候，发现token不是分号，则报<应为分号>错误，并继续执行。

**12. 应为右小括号’)’：**

​		在应该出现右小括号的时候，发现token不是右小括号，则报<应为右小括号')'>错误，并继续执行。

**13. 应为右中括号’]’：**

​		在应该出现右中括号的时候，发现token不是右中括号，则报<应为右中括号']'>错误，并继续执行。

**14. 数组初始化个数不匹配：**

​		在<变量定义及初始化>的递归分析子程序中，在定义数组时，首先用`arr_symbol_dim_1`和`arr_symbol_dim_2`分别记录数组第一维维数和第二维维数；在初始化数组时，分别用`const_sym_num_1`和`const_sym_num_2`统计数组的第一维维数和第二维维数，如果不相等，则报<数组初始化个数不匹配>错误。

**15. <常量>类型不一致：**

​		在<变量定义及初始化>和<情况语句>的递归分析子程序中，将标识符的类型作为参数传入<常量>的递归分析子程序，并在其中判断读入的常量类型和标识符类型是否匹配，如果不匹配，则报<<常量>类型不一致>错误。

**16. 缺少缺省语句：**

​		当进入<缺省>的递归分析子程序时，如果token不是default，则报<缺少缺省语句>错误。

## 4. 编码后设计

### 4.1 使用指针

​		在编码前的设计方案中，位于命名空间`symbol_table`中符号向量容器`symbol_vector`直接存储`Symbol`类的符号，但是问题在于我们从该容器中取出的符号是`Symbol`类，但是在使用该符号时，需要根据需要将其转成`Symbol`类的子类，即`VarSymbol`类、`ArrSymbol`类或`FuncSymbol`类中的一种。在C++中，自定义类的强制转换比较麻烦，因此采取的改进方案是不再直接存储symbol，而是存储指向symbol的指针，即符号向量容器变成了符号指针向量容器`symbol_ptr_vector`，其类型为`std::vector<std::shared_ptr<Symbol>>`。

> 其中，`shared_ptr`时C++11智能指针类的一种，智能指针主要用于管理在堆上分配的内存，它将普通的指针封装为一个栈对象，当栈对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而防止内存泄漏。`shared_ptr`是采用引用计数的方法，记录当前内存资源被多少个智能指针引用，该引用计数的内存在堆上分配，当新增一个时引用计数加1，当过期时引用计数减1。只有引用计数为0时，智能指针才会自动释放引用的内存资源。对`shared_ptr`进行初始化时不能将一个普通指针直接赋值给智能指针，因为一个是指针，一个是类，可以通过`make_shared`函数或者通过构造函数传入普通指针，并可以通过get函数获得普通指针。
>
> 具体使用方法：
>
> `std::shared_ptr<Symbol> symbol_ptr = std::make_shared<FuncSymbol>(func_name, symbol_type, symbol_level)`
>
> make_shared在动态内存中分配一个FuncSymbol对象并初始化它，然后返回指向此对象的shared_ptr，只是这个指针指向的是Symbol类。
>
> `std::shared_ptr<FuncSymbol> func_symbol_ptr = std::dynamic_pointer_cast<FuncSymbol>(symbol_ptr)`
>
> dynamic_pointer_cast将指向Symbol的指针转换成指向FuncSymbol的指针。

​		因此，在编码后，`Symbol`基类和`VarSymbol`类不变。

​		`ArrSymbol`的具体类成员变量和类成员函数的属性及含义如下所示。

|   类成员变量名   | 访问修饰符 | 类型 |         含义         |
| :--------------: | :--------: | :--: | :------------------: |
| arr_symbol_dim_1 |  private   | int  | 数组符号的第一维维数 |
| arr_symbol_dim_2 |  private   | int  | 数组符号的第二维维数 |

|     类成员函数名     | 访问修饰符 |                           输入参数                           | 返回类型 |           含义           |
| :------------------: | :--------: | :----------------------------------------------------------: | :------: | :----------------------: |
|      ArrSymbol       |   public   | string name, SymbolType type, int level, int arr_symbol_dim_1, int arr_symbol_dim_2 |   void   |         构造函数         |
|      ~ArrSymbol      |   public   |                             void                             |   void   |         析构函数         |
| get_arr_symbol_dim_1 |   public   |                             void                             |   int    | 返回数组符号的第一维维数 |
| get_arr_symbol_dim_2 |   public   |                             void                             |   int    | 返回数组符号的第二维维数 |

​		`FuncSymbol`的具体类成员变量和类成员函数的属性及含义如下所示。

|     类成员变量名      | 访问修饰符 |               类型                |          含义          |
| :-------------------: | :--------: | :-------------------------------: | :--------------------: |
| func_symbol_args_ptrs |  private   | vector< shared_ptr< VarSymbol > > | 函数符号参数的指针容器 |

|       类成员函数名        | 访问修饰符 |                输入参数                 |            返回类型             |          含义          |
| :-----------------------: | :--------: | :-------------------------------------: | :-----------------------------: | :--------------------: |
|        FuncSymbol         |   public   | string name, SymbolType type, int level |              void               |        构造函数        |
|        ~FuncSymbol        |   public   |                  void                   |              void               |        析构函数        |
| add_func_symbol_args_ptr  |   public   |     shared_ptr< VarSymbol > arg_ptr     |              void               | 增加函数符号参数的指针 |
| get_func_symbol_args_ptrs |   public   |                  void                   | shared_ptr< VarSymbol > arg_ptr |   返回函数符号的参数   |

​		针对`symbol_table`这个命名空间也做了改动，将**原先的成员变量变成了全局变量**。

|    成员变量名     |                       变量类型                       |                     备注                      |
| :---------------: | :--------------------------------------------------: | :-------------------------------------------: |
| symbol_ptr_vector |            vector< shared_ptr< Symbol > >            |       符号栈，按顺序存放指向符号的指针        |
|  name2index_map   | unordered_map< string, shared_ptr< vector< int > > > | 记录某个符号名在symbol_ptr_vector中对应的索引 |

​		由于在不同的作用域中可以存在同名的符号，所以每次插入新的符号时，如果`name2index_map`中有相同符号名的键，就获取最后一次放入`name2index_map`的同名符号，如果该符号的`symbol_level`和新符号的`symbol_level`相等，则说明发生<名字重定义>错误；否则，将新符号插入到`name2index_map`中。

​		`symbol_table`的成员函数及其相关描述如下表所示。

|       成员函数名       |                           输入参数                           |       返回类型       |                             备注                             |
| :--------------------: | :----------------------------------------------------------: | :------------------: | :----------------------------------------------------------: |
|      IsConSymbol       |                    SymbolType symbol_type                    |         bool         | 检查是否是常量符号类型，如果是，返回true；否则，返回false。  |
|      IsVarSymbol       |                    SymbolType symbol_type                    |         bool         | 检查是否是变量符号类型，如果是，返回true；否则，返回false。  |
|      IsArrSymbol       |                    SymbolType symbol_type                    |         bool         | 检查是否是数组符号类型，如果是，则返回true；否则，返回false。 |
|      IsFuncSymbol      |                    SymbolType symbol_type                    |         bool         | 检查是否是函数符号类型，如果是，则返回true；否则，返回false。 |
|     IsNameDefined      |                      string symbol_name                      |         bool         |    检查名字是否被定义，如果是，返回true；否则返回false。     |
|    IsNameRedefined     |             string symbol_name, int symbol_level             |         bool         |    检查名字是否重定义，如果是，返回true；否则返回false。     |
|    AddNewSymbol2Map    |                      string symbol_name                      |         void         | 将新的symbol添加到name2index_map中。如果name2index_map中已经包含这个符号的symbol_name，就直接添加到对应的索引向量中；否则，先添加该symbol_name对应的键值对，再添加该symbol。 |
|      AddVarSymbol      | string symbol_name, SymbolType symbol_type, int symbol_level |         bool         | 向符号表中添加常量符号或变量符号。返回false说明出现了<名词重定义>错误，返回true说明添加成功。 |
|      AddArrSymbol      | string arr_name, SymbolType symbol_type, int symbol_level, int arr_symbol_dim_1, int arr_symbol_dim_2 |         bool         | 向符号表中添加数组符号。返回false说明出现了<名词重定义>错误，返回true说明添加成功。 |
|     AddFuncSymbol      |  string func_name, SymbolType symbol_type, int symbol_level  |         bool         | 向符号表中添加函数符号。返回false说明出现了<名词重定义>错误，返回true说明添加成功。 |
|   DelCurLevelSymbol    |                        int cur_level                         |         void         |        退出某个作用域时，要删除该作用域内所有的标识符        |
|  GetSymbolLatestType   |                      string symbol_name                      |      SymbolType      | 得到最后一次插入的名为symbol_name的标识符的symbol_type。如果name2index_map中不存在symbol_name的键，返回OtherTypeSym。 |
|     IsWithRetFunc      |                       string func_name                       |         bool         | 判断func_name对应的标识符类型是否是IntFuncSym或CharFuncSym（调用GetSymbolLatestType即可）。如果是，返回true；否则，返回false。 |
|       CheckPara        |     string func_name, vector< int > value_para_type_syms     |         int          | 调用函数时，检查值参数表和函数参数表是否匹配。如果匹配，返回0；如果函数参数个数不匹配，返回1；如果函数参数类型不匹配，返回2；如果是其他错误，返回3。 |
| GetSymbolPtrVectorBack |                             void                             | shared_ptr< Symbol > |                   获得最新插入符号栈的符号                   |

### 4.2 语法分析预读修正

​		编码时发现一个问题，在原先的语法分析中，采用了超前扫描的形式来选择进入哪个递归分析子程序，以<变量定义及初始化>为例，只有当预读到类似`int a =`，`int a[1] =`或`int a[1][1] =`的格式时才会进入<变量定义及初始化>的递归分析子程序，但是在加入了错误处理后，有可能出现缺少']'的情况，那么就无法进入<变量定义及初始化>。因此，需要修改部分递归分析子程序的超前扫描部分。

​		在<程序>的递归分析子程序中，判断是否要进入<变量定义>的递归分析子程序时，首先判断第一个token是否是int或char，不是则报错；然后判断第二个token是否是标识符，不是则报错；然后判断第三个token是否是'('，是则报错（因为测试时只会出现规定的错误，所以如果第三个token是左括号，就进入了函数定义部分），不是则认为它是变量定义。

​		在<变量定义>的递归分析子程序中，需要判断是进入<变量定义及初始化>还是<变量定义无初始化>时，因为如果进入了变量定义，一定符合上一条条件，即当前的token是int 或 char，第二个是标识符，第三个不是'('。那么，其实只要不断读下去，如果在没读到int、char、void、','和';'的情况下读到了'='，那么就可以确实是<变量定义及初始化>，否则的话就是<变量定义无初始化>。

​		在判断是<有返回值函数调用语句>还是<无返回值函数调用语句>时要用符号表，如果符号表中有这个函数且有返回值，则进入<有返回值函数调用语句>，如果出现没有定义的函数名且后一个token是'('，则进入<无返回值函数调用语句>，然后报<未定义的名字>的错，并跳读至';'。
