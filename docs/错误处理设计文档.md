# 错误处理设计文档

## 1. 需求分析

**主需求**：

​		根据给定的文法设计并实现错误处理程序，能诊察出常见的语法和语义错误，进行错误局部化处理，并输出错误信息。

**输入输出**：

1. 输入的被编译源文件统一命名为`testfile.txt`，错误信息输出到命名为`error.txt`的结果文件中。

2. 结果文件中包含如下两种信息：

   错误所在的行号 错误的类别码

   行号与类别码之间只有一个空格，类别码严格按照表格中的小写英文字母。

**错误类别码定义**：

|                       错误类型                       | 错误类别码 |                          解释及举例                          |                           |
| :--------------------------------------------------: | :--------: | :----------------------------------------------------------: | :-----------------------: |
|                 非法符号或不符合词法                 |     a      | 例如**字符与字符串中出现非法的符号**，**符号串中无任何符号** |       InvalidSymbol       |
|                      名字重定义                      |     b      |        **同一作用域内出现相同的名字**（不区分大小写）        |       NameRedefine        |
|                     未定义的名字                     |     c      |                     **引用未定义的名字**                     |       NameNotDefine       |
|                  函数参数个数不匹配                  |     d      |             函数调用时实参个数大于或小于形参个数             |      ArgsNumNotMatch      |
|                  函数参数类型不匹配                  |     e      | 函数调用时形参为整型，实参为字符型；或形参为字符型，实参为整型 |     ArgsTypeNotMatch      |
|              条件判断中出现不合法的类型              |     f      | 条件判断的左右表达式只能为整型，其中任一表达式为字符型即报错，例如'a' == 1 | ConditionJudgeInvalidType |
|         无返回值的函数存在不匹配的return语句         |     g      | 无返回值的函数中可以没有return语句，也可以有形如return;的语句，若出现了形如return(表达式);或return();的语句均报此错误 |      NoRetFuncReturn      |
| 有返回值的函数缺少return语句或存在不匹配的return语句 |     h      | 例如有返回值的函数无任何返回语句；或有形如return;的语句；或有形如return();的语句；或return语句中表达式类型与返回值类型不一致 |     RetFuncMissReturn     |
|            数组元素的下标只能是整型表达式            |     i      |                  数组元素的下标不能是字符型                  |      ArrIndexNotInt       |
|                   不能改变常量的值                   |     j      | 这里的常量指的是声明为const的标识符。例如 const int a=1;在后续代码中如果出现了修改a值的代码，如给a赋值或用scanf获取a的值，则报错。 |        ModifyConst        |
|                       应为分号                       |     k      | 应该出现分号的地方没有分号，例如int x=1缺少分号（7种语句末尾，for语句中，常量定义末尾，变量定义末尾） |        SemicnMiss         |
|                   应为右小括号')'                    |     I      | 应该出现右小括号的地方没有右小括号，例如fun(a,b;，缺少右小括号（有/无参数函数定义，主函数，带括号的表达式，if，while，for，switch，有/无参数函数调用，读、写、return） |        RparentMiss        |
|                   应为右中括号']'                    |     m      | 应该出现右中括号的地方没有右中括号，例如int arr[2;缺少右中括号（一维/二维数组变量定义有/无初始化，因子中的一维/二维数组元素，赋值语句中的数组元素） |        RbrackMiss         |
|                 数组初始化个数不匹配                 |     n      | 任一维度的元素个数不匹配，或缺少某一维的元素即报错。例如int a[2] [2]={{1,2,3},{1,2}} |      ArrInitNotMatch      |
|                   <常量>类型不一致                   |     o      | 变量定义及初始化和switch语句中的<常量>必须与声明的类型一致。int x=’c’;int y;switch(y){case(‘1’) ….} |      VarTypeNotMatch      |
|                     缺少缺省语句                     |     p      |                switch语句中，缺少<缺省>语句。                |        MissDefault        |

**附加要求**：

1. 本次考核之外，发现错误时最好直接输出描述信息，而不是仅给出错误类型或错误情况 。

   **解决方案：设置两个布尔型常量`ERROR_TYPE_OUTPUT`和`ERROR_DESCRIPTION_ERROR`来控制两种不同的输出。**

2. 每一行中最多只有一个错误。

3. 所有错误都不会出现恶意换行的情况，包括字符、字符串中的换行符、函数调用等等。

4. 其他类型的错误，错误的行号以能够断定发现出错的一个符号的行号为准。例如有返回值的函数缺少返回语句的错误，只有当识别到函数末尾的}时仍未出现返回语句，才可以断定出错，报错行号即为}的行号。

## 2. Pascal-S编译器错误处理

> 根据PASCAL-S文法的定义，阅读编译器源代码，了解符号表的设计实现方案和错误处理实现方案；在此基础上，为自己的编译器添加符号表管理、错误处理功能（包括语法错误和语义错误），编译器源代码见pascals-compiler.docx。

​		Pascal-S的出错处理基本上沿用了PL/0的处理方法，采取了以下一些措施：

​		（1）对于在程序中遗漏了像“;”号或明显的保留字之类的符号时，或者当程序员误用了像“:=”号或“=”号之类的符号时，则除报告出错信息外，只要简单地**填上或改正这些符号**便可予以**校正**，使编译继续进行下去；

​		（2）在每个语法分析子程序出口处，检测**下一个取来的符号**是否为该语法成分的**合法后继符号**或**停止符号集合**，若不是，则应报告出错信息，并且跳读一段源程序，直至取来的符号属于该语法成分的合法后继符号集合或停止符号集合为止。停止符号集合里可以放置若干明显的能使程序重新开始分析的保留字或者其他终结符号。

​		……

## 3. 编码前设计

#### 3.1 符号表

​		我们符号表采用组织形式的是**栈式符号表**，在这种组织形式下，当遇到**识别符声明**时，就将包含有标识符属性的记录**推入堆栈**。当到达**分程序结尾**时，就将这个分程序中声明的所有标识符的记录**移出堆栈**。

> 其中，有一点疑问：书上强调一个分程序的符号表信息可能在编译的各个阶段都需要被访问，例如语法分析、语义分析、代码优化和代码生成等。因此通常情况下，编译器会为每个被编译的分程序设计一个独立的数据结构或者内存空间来存放它的符号表，直到该分程序的所有编译阶段都完成后再删除或释放相应符号表占用的空间。由于我们实现的是一遍扫描的生成程序，所以理论上在语法分析程序中一个分程序执行完毕，编译阶段的工作已经完成了，所以似乎不再需要设计一个内存空间来存放符号表，直接从栈中弹出即可（？）。正确性有待商榷，因此将需要将弹栈设计成一个函数，便于之后修改。

​		在栈式符号表中**插入**操作，只需要将新纪录推入栈顶单元即可。在分程序结构的语言中允许在不同分程序中存在重复的名字声明，因此在插入前要检查名字是否有重复声明的错误。使用线性查找法时，**只需要检查正在编译的最后一个分程序中所声明的名字记录**就可以了。

​		**查表**操作需要对表进行从顶到底的线性搜索。

​		在栈式符号表的**定位**操作中，在分程序索引表的顶端将产生一个新的分程序索引项，并赋予当前符号表栈栈顶的地址。

​		**重定位**操作将有效地清楚刚刚被编译完的分程序在栈式符号表中的所有记录；也可以是物理上把被删除的记录移到一个失效区中。

**具体实现**：

​		`symbol.h`中定义一个符号的基类`Symbol`，具体类成员变量和类成员函数的属性及含义如下所示。

| 类成员变量名 | 访问修饰符 |    类型    |            含义            |
| :----------: | :--------: | :--------: | :------------------------: |
| symbol_name  | protected  |   string   |         符号的名字         |
| symbol_type  | protected  | SymbolType |         符号的类型         |
| symbol_layer | protected  |    int     | 符号声明所在的分程序的层次 |

|   类成员函数名   | 访问修饰符 |                输入参数                 |  返回类型  |              含义              |
| :--------------: | :--------: | :-------------------------------------: | :--------: | :----------------------------: |
|      Symbol      |   public   | string name, SymbolType type, int layer |   Symbol   |            构造函数            |
|     ~Symbol      |   public   |                  void                   |    void    |            析构函数            |
| get_symbol_name  |   public   |                  void                   |   string   |         返回符号的名字         |
| get_symbol_type  |   public   |                  void                   | SymbolType |         返回符号的类型         |
| get_symbol_layer |   public   |                  void                   |    int     | 返回符号声明所在的分程序的层次 |

​		其中，`SymbolType`为自己定义的枚举类，具体枚举变量如下。

```c++
enum SymbolType {
	IntConSym,		// 整型常量符号
	CharConSym,		// 字符常量符号
	IntVarSym,		// 整型变量符号
	CharVarSym,		// 字符变量符号
	IntArrSym,		// 整型数组符号
	CharArrSym,		// 字符数组符号
	VoidFuncSym,	// 无返回值函数符号
	IntFuncSym,		// 返回整型函数符号
	CharFuncSym,	// 返回字符函数符号
};
```

​		基于`Symbol`基类，有派生出了三个派生类`VarSymbol`、`ArrSymbol`和`FuncSymbol`，分别表示变量和常量符号、数组符号和函数符号。

​		`VarSymbol`的具体类成员变量和类成员函数的属性及含义如下所示。

|   类成员变量名   | 访问修饰符 | 类型 |          含义          |
| :--------------: | :--------: | :--: | :--------------------: |
| var_symbol_value |  private   | int  | 变量符号或常量符号的值 |

|     类成员函数名     | 访问修饰符 |                输入参数                 | 返回类型 |            含义            |
| :------------------: | :--------: | :-------------------------------------: | :------: | :------------------------: |
|      VarSymbol       |   public   | string name, SymbolType type, int layer |   void   |          构造函数          |
|      ~VarSymbol      |   public   |                  void                   |   void   |          析构函数          |
| set_var_symbol_value |   public   |                int value                |   void   | 设置变量符号或常量符号的值 |
| get_var_symbol_value |   public   |                  void                   |   int    | 返回变量符号或常量符号的值 |

​		`ArrSymbol`的具体类成员变量和类成员函数的属性及含义如下所示。

|     类成员变量名     | 访问修饰符 |     类型      |      含义      |
| :------------------: | :--------: | :-----------: | :------------: |
| arr_symbol_dimension |  private   | vector< int > | 数组符号的维数 |

|       类成员函数名       | 访问修饰符 |                输入参数                 |   返回类型    |        含义        |
| :----------------------: | :--------: | :-------------------------------------: | :-----------: | :----------------: |
|        ArrSymbol         |   public   | string name, SymbolType type, int layer |     void      |      构造函数      |
|        ~ArrSymbol        |   public   |                  void                   |     void      |      析构函数      |
| add_arr_symbol_dimension |   public   |              int dimension              |     void      | 增加数组符号的维数 |
| get_arr_symbol_dimension |   public   |                  void                   | vector< int > | 返回数组符号的维数 |

​		`FuncSymbol`的具体类成员和类成员函数的属性及含义如下所示。

|   类成员变量名   | 访问修饰符 |  类型   |      含义      |
| :--------------: | :--------: | :-----: | :------------: |
| func_symbol_args |  private   | private | 函数符号的参数 |

| 类成员函数名         | 访问修饰符 | 输入参数                                | 返回类型             | 含义               |
| -------------------- | ---------- | --------------------------------------- | -------------------- | ------------------ |
| FuncSymbol           | public     | string name, SymbolType type, int layer | void                 | 构造函数           |
| ~FuncSymbol          | public     | void                                    | void                 | 析构函数           |
| add_func_symbol_args | public     | VarSymbol arg                           | void                 | 增加函数符号的参数 |
| get_func_symbol_args | public     | void                                    | vector < VarSymbol > | 返回函数符号的参数 |

​		`symbol.h`中定义一个名为`symbol_table`的命名空间，其中包含一个类型为`std::vector<Symbol>`的符号向量容器`symbol_vector`和一个类型为`std::unordered_map<std::string, std::vector<int>>`的无序哈希表`name2index_map`。

​		`symbol_vector`按顺序记录符号，`name2index_map`记录某符号名在`symbol_vector`中对应的索引vector，因为在不同分程序中允许存在重复的名字声明。每次插入符号时，如果`name2index_map`中存在相同`name`的键，只需要判断该name对应的索引vector的最后一项索引对应的符号的layer和插入的符号的layer是否相同即可。



