# 代码优化设计文档

## 1. 常数合并

​		常数合并是将能在编译时计算出值得表达式用其相应的值替代。

​		在本项目中，常数合并的优化时针对目标代码进行的。由于在之前中间代码的设计时，设计了`ADDU`、`SUBU`、`MUL`和`DIVI`四种操作符，其左操作数和右操作数有可能是变量操作数，也有可能是立即数操作数；但是在MIPS体系结构下，没有直接针对两个立即数的加减乘除的操作数，因为如果直接生成目标代码的话，一句中间代码会生成多句目标代码。

​		基于以上的情况，我们进行常数合并的优化，如果左右操作数都是立即操作数，则可以在生成目标代码的过程中，直接计算出运算结果，然后只需要一句`li`指令即可完成等价的操作。例如，对于中间代码`DIVI $s0, 20, 4`，在优化前需要以下指令：

```
li $a0, 20
li $a1, 4
div $a0, $a1
mflo $s0
```

而在优化后，只需要以下指令：

```
li $s0, 5
```

## 2. 窥孔优化

​		如果采用从中间代码到目标代码逐条生成的方法，也就是从代码生成时没输入一条中间代码，便生成并输出其对应的目标代码，目标代码中通常会含有大量的冗余指令或者较低效率的指令。通过一系列简单的优化方法，通常称之为窥孔优化，可以优先地减少这些冗余指令，并改善目标代码的质量。窥孔优化关注在目标指令的一个较短的序列上，通常称之为“窥孔”，例如几条目标指令，并通过删除其中的冗余代码，或者用更高效简洁的新代码来替代其中的部分代码，达到提升目标代码质量的目标。

​		本项目实现的窥孔优化主要体现在运算操作的特殊情况。

### 2.1 简单算术指令化简或删除

​		对于立即数减变量时，立即数为0的情况，例如中间代码`SUBU $s0, 0, $s1`，在优化前需要以下指令：

```
addiu $s0, $s1, 0
neg $s0, $s0
```

而在优化后，只需要以下指令：

```
neg $s0, $s1 
```

​		对于立即数除变量时，立即数为0的情况，例如中间代码`DIVI $s0, 0, $s1`，在优化前需要以下指令：

```
li $a0, 0
div $a0, $s1
mflo $s0
```

而在优化后，只需要以下指令：

```
li $s0, 0
```

### 2.2 运算强度削弱

​		如果需要某个整数乘以2或者2的幂次常数，与乘法指令比较，更高效的指令是采用向左移位的方法进行运算；如果对某个整型变量除以2或者2的幂次常数，与除法指令比较，更高效的指令是采用向右移位的进行运算。

​		对于乘法指令而言，如果立即数是2的幂次常数，首先求出该立即数的绝对值，并求其以2为底的对数，然后`sll`指令向左移相应的位数，如果原立即数是负数，则还需要进行`neg`取负操作。例如，对于中间代码`MUL $s0, -8, $s1`，在优化前需要以下指令：

```
mul $s0, $s1, -8
```

在优化后需要以下指令：

```
sll $s0, $s1, 3
neg $s0, $s0
```

​		虽然看似指令数增加了，但效率却提高了。此外，对于变量乘0或乘-1的情况，也可以做简单的优化，此处就不赘述了。

​		对于除法指令而言，如果立即数是2的幂次常数，首先求出该立即数的绝对值，并求其以2为底的对数，然后不能像乘法那样做简单的右移位，因为像`-9/4`这样的计算，直接做简单的右移位，需要通过`movn`指令来实现。例如，对于中间代码`DIVI $s0, $s1, -8`，在优化前需要以下指令：

```
li $a0, -8
div $s1, $a0
mflo $s0
```

在优化后需要以下指令：

```
movn $a0, $s1
addiu $a1, $s1, 7
slt $a2, $s1, $0
movn $a0, $a1, $a2
sra $s0, $a0, 3
neg $s0, $s0
```

​		虽然看似指令数增加了，但效率却提高了。此外，对于0除以变量的情况，也可以做简单的优化，此处就不赘述了。

## 3. 死代码删除

​		优化后变量x，在通过它的定义点的任何一条路径上都不再被使用，根据此前对活跃变量的定义，可以认为x在它的定义点后是否活跃，或者死的。通过活跃变量分析，可以将所有此类存在定义但又从来不再被引用的变量找出来，并将该定义点删除，这个过程被称为死代码删除。

​		死代码删除的大致框架是首先通过对中间代码进行基本块划分，然后通过`GetDeadCodes`函数找出所有死代码所在的行，并将这些死代码从中间代码中删除，然后重复以上操作，直到某一次`GetDeadCodes`找不到新的死代码了，表示死代码已被删尽。

​		`GetDeadCodes`主要进行的任务就是活跃变量分析，和生成目标代码时的过程类似。是在基本块中，计算每句语句的数据流信息，判断该语句是否是冗余代码。